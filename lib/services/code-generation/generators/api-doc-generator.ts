import { OpenAPISpec, GenerationOptions } from '../types';
import { FlowStructure } from '../parsers/flow-analyzer';

export class APIDocGenerator {
  async generateAPIDoc(
    flowStructure: FlowStructure,
    options: GenerationOptions
  ): Promise<OpenAPISpec> {
    const paths = this.generatePaths(flowStructure, options);
    const schemas = this.generateSchemas(flowStructure, options);

    return {
      openapi: '3.0.0',
      info: {
        title: options.language === 'zh' ? '生成的API文档' : 'Generated API Documentation',
        version: '1.0.0',
        description: options.language === 'zh' 
          ? '此API文档由IdeaCanvas自动生成' 
          : 'This API documentation was automatically generated by IdeaCanvas'
      },
      paths,
      components: {
        schemas
      }
    };
  }

  private generatePaths(flowStructure: FlowStructure, options: GenerationOptions): Record<string, any> {
    const paths: Record<string, any> = {};
    const processedEndpoints = new Set();

    // 从API节点收集端点
    for (const api of flowStructure.apis) {
      for (const apiCall of api.node.apiCalls) {
        const key = `${apiCall.method}_${apiCall.endpoint}`;
        if (processedEndpoints.has(key)) continue;
        processedEndpoints.add(key);

        if (!paths[apiCall.endpoint]) {
          paths[apiCall.endpoint] = {};
        }

        paths[apiCall.endpoint][apiCall.method.toLowerCase()] = this.generateOperation(
          apiCall,
          api,
          flowStructure,
          options
        );
      }
    }

    // 从页面节点收集API调用
    for (const page of flowStructure.pages) {
      for (const apiCall of page.node.apiCalls) {
        const key = `${apiCall.method}_${apiCall.endpoint}`;
        if (processedEndpoints.has(key)) continue;
        processedEndpoints.add(key);

        if (!paths[apiCall.endpoint]) {
          paths[apiCall.endpoint] = {};
        }

        paths[apiCall.endpoint][apiCall.method.toLowerCase()] = this.generateOperation(
          apiCall,
          page,
          flowStructure,
          options
        );
      }
    }

    return paths;
  }

  private generateOperation(
    apiCall: any,
    context: any,
    flowStructure: FlowStructure,
    options: GenerationOptions
  ): any {
    const operation: any = {
      summary: this.generateSummary(apiCall, context, options),
      description: this.generateDescription(apiCall, context, options),
      operationId: this.generateOperationId(apiCall),
      tags: [context.node.title],
      responses: this.generateResponses(apiCall, options)
    };

    // 添加参数
    const parameters = this.generateParameters(apiCall, options);
    if (parameters.length > 0) {
      operation.parameters = parameters;
    }

    // 添加请求体
    if (['POST', 'PUT', 'PATCH'].includes(apiCall.method)) {
      operation.requestBody = this.generateRequestBody(apiCall, context, options);
    }

    return operation;
  }

  private generateSummary(apiCall: any, context: any, options: GenerationOptions): string {
    const methodVerbs = {
      zh: {
        GET: '获取',
        POST: '创建',
        PUT: '更新',
        DELETE: '删除',
        PATCH: '部分更新'
      },
      en: {
        GET: 'Get',
        POST: 'Create',
        PUT: 'Update',
        DELETE: 'Delete',
        PATCH: 'Patch'
      }
    };

    const verb = methodVerbs[options.language][apiCall.method as keyof typeof methodVerbs.zh] || apiCall.method;
    const resource = this.extractResourceName(apiCall.endpoint);

    return `${verb} ${resource}`;
  }

  private generateDescription(apiCall: any, context: any, options: GenerationOptions): string {
    const descriptions = {
      zh: {
        GET: `获取${context.node.title}相关的数据`,
        POST: `创建新的${context.node.title}记录`,
        PUT: `更新${context.node.title}信息`,
        DELETE: `删除${context.node.title}记录`,
        PATCH: `部分更新${context.node.title}信息`
      },
      en: {
        GET: `Retrieve data related to ${context.node.title}`,
        POST: `Create a new ${context.node.title} record`,
        PUT: `Update ${context.node.title} information`,
        DELETE: `Delete ${context.node.title} record`,
        PATCH: `Partially update ${context.node.title} information`
      }
    };

    return descriptions[options.language][apiCall.method as keyof typeof descriptions.zh] || 
           `${apiCall.method} operation for ${context.node.title}`;
  }

  private generateOperationId(apiCall: any): string {
    const parts = apiCall.endpoint.split('/').filter(Boolean);
    const method = apiCall.method.toLowerCase();
    const resource = parts[parts.length - 1] || 'resource';
    
    return `${method}${resource.charAt(0).toUpperCase()}${resource.slice(1)}`;
  }

  private generateParameters(apiCall: any, options: GenerationOptions): any[] {
    const parameters: any[] = [];

    // 路径参数
    const pathParams = apiCall.endpoint.match(/{([^}]+)}/g);
    if (pathParams) {
      pathParams.forEach((param: string) => {
        const paramName = param.slice(1, -1);
        parameters.push({
          name: paramName,
          in: 'path',
          required: true,
          description: options.language === 'zh' 
            ? `${paramName}的唯一标识符` 
            : `Unique identifier for ${paramName}`,
          schema: {
            type: 'string'
          }
        });
      });
    }

    // 查询参数（GET请求）
    if (apiCall.method === 'GET' && apiCall.parameters) {
      Object.entries(apiCall.parameters).forEach(([key, value]) => {
        parameters.push({
          name: key,
          in: 'query',
          required: false,
          description: options.language === 'zh' 
            ? `${key}参数` 
            : `${key} parameter`,
          schema: {
            type: typeof value === 'number' ? 'integer' : 'string'
          }
        });
      });
    }

    return parameters;
  }

  private generateRequestBody(apiCall: any, context: any, options: GenerationOptions): any {
    const schemaName = this.generateSchemaName(apiCall.endpoint, apiCall.method);
    
    return {
      description: options.language === 'zh' 
        ? `${context.node.title}的请求数据` 
        : `Request data for ${context.node.title}`,
      required: true,
      content: {
        'application/json': {
          schema: {
            $ref: `#/components/schemas/${schemaName}`
          }
        }
      }
    };
  }

  private generateResponses(apiCall: any, options: GenerationOptions): any {
    const responses: any = {
      '200': {
        description: options.language === 'zh' ? '成功响应' : 'Successful response',
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                success: { type: 'boolean' },
                data: { type: 'object' },
                message: { type: 'string' }
              }
            }
          }
        }
      },
      '400': {
        description: options.language === 'zh' ? '请求参数错误' : 'Bad request'
      },
      '401': {
        description: options.language === 'zh' ? '未授权' : 'Unauthorized'
      },
      '404': {
        description: options.language === 'zh' ? '资源未找到' : 'Resource not found'
      },
      '500': {
        description: options.language === 'zh' ? '服务器错误' : 'Internal server error'
      }
    };

    // 特定方法的响应
    if (apiCall.method === 'POST') {
      responses['201'] = {
        description: options.language === 'zh' ? '创建成功' : 'Created successfully',
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                success: { type: 'boolean' },
                data: { type: 'object' },
                id: { type: 'string' }
              }
            }
          }
        }
      };
    }

    if (apiCall.method === 'DELETE') {
      responses['204'] = {
        description: options.language === 'zh' ? '删除成功（无内容）' : 'Deleted successfully (no content)'
      };
    }

    return responses;
  }

  private generateSchemas(flowStructure: FlowStructure, options: GenerationOptions): Record<string, any> {
    const schemas: Record<string, any> = {};

    // 从数据模型生成schemas
    for (const dataModel of flowStructure.dataModels) {
      const schemaName = this.toCamelCase(dataModel.node.title);
      schemas[schemaName] = this.generateSchemaFromDataModel(dataModel, options);
    }

    // 从API调用生成请求/响应schemas
    const allAPICalls = [
      ...flowStructure.apis.flatMap(api => api.node.apiCalls),
      ...flowStructure.pages.flatMap(page => page.node.apiCalls)
    ];

    for (const apiCall of allAPICalls) {
      if (['POST', 'PUT', 'PATCH'].includes(apiCall.method)) {
        const schemaName = this.generateSchemaName(apiCall.endpoint, apiCall.method);
        if (!schemas[schemaName]) {
          schemas[schemaName] = this.generateRequestSchema(apiCall, options);
        }
      }
    }

    return schemas;
  }

  private generateSchemaFromDataModel(dataModel: any, options: GenerationOptions): any {
    const properties: Record<string, any> = {};
    const required: string[] = [];

    for (const field of dataModel.node.dataModel) {
      properties[field.name] = {
        type: this.mapFieldType(field.type),
        description: field.name
      };

      if (field.required) {
        required.push(field.name);
      }

      if (field.validation) {
        this.addValidationToSchema(properties[field.name], field.validation);
      }
    }

    return {
      type: 'object',
      title: dataModel.node.title,
      description: options.language === 'zh' 
        ? `${dataModel.node.title}的数据模型` 
        : `Data model for ${dataModel.node.title}`,
      properties,
      required: required.length > 0 ? required : undefined
    };
  }

  private generateRequestSchema(apiCall: any, options: GenerationOptions): any {
    // 基于端点名称生成默认schema
    const resourceName = this.extractResourceName(apiCall.endpoint);
    
    return {
      type: 'object',
      title: `${apiCall.method} ${resourceName} Request`,
      description: options.language === 'zh' 
        ? `${resourceName}的${apiCall.method}请求体` 
        : `${apiCall.method} request body for ${resourceName}`,
      properties: {
        // 默认属性，实际项目中应该从上下文推断
        name: { type: 'string' },
        description: { type: 'string' },
        data: { type: 'object' }
      },
      required: ['name']
    };
  }

  private mapFieldType(type: string): string {
    const typeMap: Record<string, string> = {
      'string': 'string',
      'number': 'number',
      'boolean': 'boolean',
      'date': 'string',
      'array': 'array',
      'object': 'object'
    };

    return typeMap[type] || 'string';
  }

  private addValidationToSchema(schema: any, validationRules: any[]): void {
    for (const rule of validationRules) {
      switch (rule.type) {
        case 'minLength':
          schema.minLength = rule.value;
          break;
        case 'maxLength':
          schema.maxLength = rule.value;
          break;
        case 'pattern':
          schema.pattern = rule.value;
          break;
        case 'min':
          schema.minimum = rule.value;
          break;
        case 'max':
          schema.maximum = rule.value;
          break;
        case 'email':
          schema.format = 'email';
          break;
        case 'url':
          schema.format = 'url';
          break;
      }
    }
  }

  private extractResourceName(endpoint: string): string {
    const parts = endpoint.split('/').filter(Boolean);
    const lastPart = parts[parts.length - 1];
    
    // 移除路径参数
    const cleanPart = lastPart.replace(/{[^}]+}/g, '');
    
    return cleanPart || 'resource';
  }

  private generateSchemaName(endpoint: string, method: string): string {
    const resource = this.extractResourceName(endpoint);
    const camelCaseResource = this.toCamelCase(resource);
    
    return `${method.charAt(0)}${method.slice(1).toLowerCase()}${camelCaseResource}Request`;
  }

  private toCamelCase(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
      .replace(/^./, chr => chr.toUpperCase());
  }
}